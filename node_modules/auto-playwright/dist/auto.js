"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.auto = void 0;
const config_1 = require("./config");
const completeTask_1 = require("./completeTask");
const errors_1 = require("./errors");
const getSnapshot_1 = require("./getSnapshot");
const auto = async (task, config, options) => {
    if (!config || !config.page) {
        throw Error("The auto() function is missing the required `{ page }` argument.");
    }
    const { test, page } = config;
    if (!test) {
        return await runTask(task, page, options);
    }
    return test.step(`auto-playwright.ai '${task}'`, async () => {
        const result = await runTask(task, page, options);
        if (result.errorMessage) {
            throw new errors_1.UnimplementedError(result.errorMessage);
        }
        if (result.assertion !== undefined) {
            return result.assertion;
        }
        if (result.query !== undefined) {
            return result.query;
        }
        return undefined;
    });
};
exports.auto = auto;
async function runTask(task, page, options) {
    if (task.length > config_1.MAX_TASK_CHARS) {
        throw new Error(`Provided task string is too long, max length is ${config_1.MAX_TASK_CHARS} chars.`);
    }
    const result = await (0, completeTask_1.completeTask)(page, {
        task,
        snapshot: await (0, getSnapshot_1.getSnapshot)(page),
        options: options
            ? {
                model: options.model ?? "gpt-4o",
                debug: options.debug ?? false,
                openaiApiKey: options.openaiApiKey,
                openaiBaseUrl: options.openaiBaseUrl,
                openaiDefaultQuery: options.openaiDefaultQuery,
                openaiDefaultHeaders: options.openaiDefaultHeaders,
            }
            : undefined,
    });
    return result;
}
